---
layout: post
title: 识别字符串中的 Emoji 表情
date: 2019-01-01 20:36:24
---

### Unicode 字符集

Unicode 标准为世界上几乎所有的[^1]书写系统里所使用的每一个字符或符号定义了一个唯一的数字。这个数字叫做码点（code points），以 U+xxxx 这样的格式写成，格式里的 xxxx 代表四到六个十六进制的数。

最初，Unicode 编码是被设计为 16 位的，提供了 65,536 个字符的空间。后来，考虑到要编码历史上的文字以及一些很少使用的日本汉字和中国汉字，Unicode 编码扩展到了 21 位（从 U+0000 到 U+10FFFF）。所以，我们现在接触到的 Unicode 是 21 位的编码。

编码空间被分成 17 个平面（plane），每个平面有 65,536 个字符。

![](../../../images/UnicodePlanes.jpg)

0 号平面叫做「基本多文种平面」（Basic Multilingual Plane, BMP），涵盖了几乎所有你能遇到的字符。其它平面叫做补充平面，大多是空的。

### UTF 编码

Unicode 定义了字符到码点的映射，具体如何在计算机上存储，就需要使用 UTF （Unicode Transformation Formats，简称 UTF）编码了。有三种编码编码格式，UIF-32、UTF-16 和 UTF-8，看名字就知道它们含义，32、16、8 表示用于存储长度。使用 32 位存储一个码点（码点长度 21 位）太浪费空间了，现实中很少使用。UTF-16 使用 16 位固定长度的码元，BMP 的范围在 0000-FFFF 之间，一个码点直接与一个码元相映射，使用 UTF-16 比 UTF-32 节省一半的空间。其它平面的字符超过了 16 位的表示范围，可以使用两个 UTF-16 码元组合起来表示，叫做代理对（surrogate pair）。

###NSSTring 存储

NSString 对象代表的其实是用 UTF-16 编码的码元组成的数组。相应地，length 方法的返回值也是字符串包含的码元个数（而不是字符个数）。试着打印 😛(U+1F61B) 的长度，输出 2。因为 U+1F61B 超出了 BMP 的范围，需要使用两个 UTF-16 码元组合成代理对表示。

```objc
 NSString *emoji = @"😛";
 NSLog(@"emoji.length: %@", @(emoji.length)); // emoji.length: 2
```

在工作中经常会遇到限制用户输入字符个数的需求，比如要求用户名最长不超过 10 个字符，一般情况下使用 length 判断就可以了，如果用户输入了 emoji 表情，使用 length 判断可能就不符合要求了。用户输入了 3 个 👨🏻‍⚕️（1F468 1F3FB 200D 2695 FE0F），打印出length 的长度是 21（每个 👨🏻‍⚕️ 长度为: 2 + 2 + 1 + 1 + 1），已经超过 10 ，提示用超长了肯定不合理。如何判断字符长度呢？`enumerateSubstringsInRange:options:usingBlock:` 方法以字符为单位进行遍历，使用这个方法可以统计字符真正的长度。

```objc
__block NSUInteger realLength = 0;
[emoji enumerateSubstringsInRange:NSMakeRange(0, emoji.length) options:NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {
    NSLog(@"==> subRange:%@, subStr:%@", NSStringFromRange(substringRange), substring);
    realLength += 1;
}];
NSLog(@"realLength: %@", @(realLength)); // realLength: 3
```
###emoji

// 


